Constructor Overloading in Java
Constructor Overloading in Java means having more than one constructor 
in a class with different
 parameter lists (i.e., different number or type of parameters).

It allows the creation of objects in different ways using different sets of data


class X
 {
 	X()
 	{

 	}
 	X(int a)
 	{
            System.out.println("hi" + a);
 	}
 	X(int b)
 	{
           System.out.println("bye" + b);
 	}
 }


 class Test
{
	
		public static void main(String arg[])
		{
			
		   X ob=new X(10);	
		}
}


o/p:
error
C:\Users\LENOVO\OneDrive\Desktop\JAVAPROGRAMOOPS>javac Test.java
Test.java:11: error: constructor X(int) is already defined in class X
        X(int b)
        ^
1 error



 class X
 {
 	X()
 	{

 	}
 	X(int a)
 	{
            System.out.println("hi  " + a);
 	}
 	X(double b)
 	{
           System.out.println("bye "+ b);
 	}
 	X(int a,int b) // 2argument 
 	{
 		System.out.println("ok ");
 	}
 	X(int a,double b) 
 	{

 	}
 	X(double a ,int b)   //oreder
 	{

 	}


 }


 class Test
{
	
		public static void main(String arg[])
		{
			
		   X ob=new X(10);	
		   X obj=new X(2.5);

		}
}

hi  10
bye   2.5



public final class java.lang.String implements java.io.Serializable, java.lang.Comparable<java.lang.String>, java.lang.CharSequence, java.lang.constant.Constable, java.lang.constant.ConstantDesc {
  static final boolean COMPACT_STRINGS;
  public static final java.util.Comparator<java.lang.String> CASE_INSENSITIVE_ORDER;
  static final byte LATIN1;
  static final byte UTF16;
  public java.lang.String();
  public java.lang.String(java.lang.String);
  public java.lang.String(char[]);
  public java.lang.String(char[], int, int);
  public java.lang.String(int[], int, int);
  public java.lang.String(byte[], int, int, int);
  public java.lang.String(byte[], int);
  public java.lang.String(byte[], int, int, java.lang.String) throws java.io.UnsupportedEncodingException;
  public java.lang.String(byte[], int, int, java.nio.charset.Charset);
  static java.lang.String newStringUTF8NoRepl(byte[], int, int);
  static java.lang.String newStringNoRepl(byte[], java.nio.charset.Charset) throws java.nio.charset.CharacterCodingException;
  static byte[] getBytesUTF8NoRepl(java.lang.String);
  static byte[] getBytesNoRepl(java.lang.String, java.nio.charset.Charset) throws java.nio.charset.CharacterCodingException;
  static int decodeASCII(byte[], int, char[], int, int);
  public java.lang.String(byte[], java.lang.String) throws java.io.UnsupportedEncodingException;
  public java.lang.String(byte[], java.nio.charset.Charset);
  public java.lang.String(byte[], int, int);
  public java.lang.String(byte[]);
  public java.lang.String(java.lang.StringBuffer);
  public java.lang.String(java.lang.StringBuilder);
  public int length();
  public boolean isEmpty();
  public char charAt(int);
  public int codePointAt(int);
  public int codePointBefore(int);
  public int codePointCount(int, int);
  public int offsetByCodePoints(int, int);
  public void getChars(int, int, char[], int);
  public void getBytes(int, int, byte[], int);
  public byte[] getBytes(java.lang.String) throws java.io.UnsupportedEncodingException;
  public byte[] getBytes(java.nio.charset.Charset);
  public byte[] getBytes();
  public boolean equals(java.lang.Object);
  public boolean contentEquals(java.lang.StringBuffer);
  public boolean contentEquals(java.lang.CharSequence);
  public boolean equalsIgnoreCase(java.lang.String);
  public int compareTo(java.lang.String);
  public int compareToIgnoreCase(java.lang.String);
  public boolean regionMatches(int, java.lang.String, int, int);
  public boolean regionMatches(boolean, int, java.lang.String, int, int);
  public boolean startsWith(java.lang.String, int);
  public boolean startsWith(java.lang.String);
  public boolean endsWith(java.lang.String);
  public int hashCode();
  public int indexOf(int);
  public int indexOf(int, int);
  public int lastIndexOf(int);
  public int lastIndexOf(int, int);
  public int indexOf(java.lang.String);
  public int indexOf(java.lang.String, int);
  static int indexOf(byte[], byte, int, java.lang.String, int);
  public int lastIndexOf(java.lang.String);
  public int lastIndexOf(java.lang.String, int);
  static int lastIndexOf(byte[], byte, int, java.lang.String, int);
  public java.lang.String substring(int);
  public java.lang.String substring(int, int);
  public java.lang.CharSequence subSequence(int, int);
  public java.lang.String concat(java.lang.String);
  public java.lang.String replace(char, char);
  public boolean matches(java.lang.String);
  public boolean contains(java.lang.CharSequence);
  public java.lang.String replaceFirst(java.lang.String, java.lang.String);
  public java.lang.String replaceAll(java.lang.String, java.lang.String);
  public java.lang.String replace(java.lang.CharSequence, java.lang.CharSequence);
  public java.lang.String[] split(java.lang.String, int);
  public java.lang.String[] split(java.lang.String);
  public static java.lang.String join(java.lang.CharSequence, java.lang.CharSequence...);
  static java.lang.String join(java.lang.String, java.lang.String, java.lang.String, java.lang.String[], int);
  public static java.lang.String join(java.lang.CharSequence, java.lang.Iterable<? extends java.lang.CharSequence>);
  public java.lang.String toLowerCase(java.util.Locale);
  public java.lang.String toLowerCase();
  public java.lang.String toUpperCase(java.util.Locale);
  public java.lang.String toUpperCase();
  public java.lang.String trim();
  public java.lang.String strip();
  public java.lang.String stripLeading();
  public java.lang.String stripTrailing();
  public boolean isBlank();
  public java.util.stream.Stream<java.lang.String> lines();
  public java.lang.String indent(int);
  public java.lang.String stripIndent();
  public java.lang.String translateEscapes();
  public <R> R transform(java.util.function.Function<? super java.lang.String, ? extends R>);
  public java.lang.String toString();
  public java.util.stream.IntStream chars();
  public java.util.stream.IntStream codePoints();
  public char[] toCharArray();
  public static java.lang.String format(java.lang.String, java.lang.Object...);
  public static java.lang.String format(java.util.Locale, java.lang.String, java.lang.Object...);
  public java.lang.String formatted(java.lang.Object...);
  public static java.lang.String valueOf(java.lang.Object);
  public static java.lang.String valueOf(char[]);
  public static java.lang.String valueOf(char[], int, int);
  public static java.lang.String copyValueOf(char[], int, int);
  public static java.lang.String copyValueOf(char[]);
  public static java.lang.String valueOf(boolean);
  public static java.lang.String valueOf(char);
  public static java.lang.String valueOf(int);
  public static java.lang.String valueOf(long);
  public static java.lang.String valueOf(float);
  public static java.lang.String valueOf(double);
  public native java.lang.String intern();
  public java.lang.String repeat(int);
  void getBytes(byte[], int, byte);
  void getBytes(byte[], int, int, byte, int);
  java.lang.String(char[], int, int, java.lang.Void);
  java.lang.String(java.lang.AbstractStringBuilder, java.lang.Void);
  java.lang.String(byte[], byte);
  byte coder();
  byte[] value();
  boolean isLatin1();
  static void checkIndex(int, int);
  static void checkOffset(int, int);
  static void checkBoundsOffCount(int, int, int);
  static void checkBoundsBeginEnd(int, int, int);
  static java.lang.String valueOfCodePoint(int);
  public java.util.Optional<java.lang.String> describeConstable();
  public java.lang.String resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup);
  public int compareTo(java.lang.Object);
  public java.lang.Object resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup) throws java.lang.ReflectiveOperationException;
  static {};
}


class Student {
    int id;
    String name;

    // Constructor 1: No parameters
    Student() {
        id = 0;
        name = "Unknown";
    }

    // Constructor 2: One parameter
    Student(int i) {
        id = i;
        name = "Unknown";
    }

    // Constructor 3: Two parameters
    Student(int i, String n) {
        id = i;
        name = n;
    }

    void display() {
        System.out.println("ID: " + id + ", Name: " + name);
    }
}

public class Main {
    public static void main(String[] args) {
        Student s1 = new Student();
        Student s2 = new Student(101);
        Student s3 = new Student(102, "Jitendra");

        s1.display();  // ID: 0, Name: Unknown
        s2.display();  // ID: 101, Name: Unknown
        s3.display();  // ID: 102, Name: Jitendra
    }
}


constructor chainging
________________________

Constructor chaining is the process of calling one constructor from another constructor within the same class or from the parent class.

üî∏ Two Types of Constructor Chaining:
Within the same class using this()

From a parent class using super()



without constructor chaining  2 object

 class X
 {
 	X()
 	{
 	    //super()  it call parent class constructor 
         System.out.println("bye");
 	}
 	X(int a)
 	{
 		//super()  it call parent class constructor 
            System.out.println("hi  " + a);
 	}

 }

 class Test
{
	
		public static void main(String arg[])
		{
			
		   X ob=new X(10);	
		   X obj=new X();

		}
}

o/p:
hi  10
bye




constructor chaining
________________________

this() :    it call own class zero argument constructor 

 class X
 {
 	X()
 	{
         System.out.println("bye");
 	}
 	X(int a)
 	{
 		this(); // it call own class zero argumnet constructor
 		//super()  that must be first line   both this() and super() write inside constructor not possible
            System.out.println("hi  " + a);
 	}
 
 }

 class Test
{
	
		public static void main(String arg[])
		{
			
		   X ob=new X(10);	
		   

		}
}

o/p:
bye
hi  10



 class X
 {
 	X()
 	{
            this(10); // it call parameter constructor  own class
         System.out.println("bye");
 	}
 	X(int a)
 	{
 		
            System.out.println("hi  " + a);
 	}
 
 }


 class Test
{
	
		public static void main(String arg[])
		{
			
		   X ob=new X();	
		   

		}
}

C:\Users\LENOVO\OneDrive\Desktop\JAVAPROGRAMOOPS>java Test
hi  10
bye


 2. Constructor Chaining using super() (Parent Class)


 class Person {
    Person() {
        System.out.println("Person constructor");
    }
}

class Employee extends Person {
    Employee() {
        super();  // Calls Person's constructor
        System.out.println("Employee constructor");
    }
}

public class Main {
    public static void main(String[] args) {
        Employee e = new Employee();
    }
}





this() and super() must be the first statement in the constructor.

You cannot use both this() and super() in the same constructor.

Java automatically adds super() if not explicitly specified in subclass constructor

Why Use Constructor Chaining?
To avoid code duplication.

To create flexible object initialization.

To centralize logic in one constructor and reuse.




class BankAccount {
    String name;
    String accNo;
    double balance;

    // Constructor 1 - No details provided
    BankAccount() {
        this("Unnamed", "0000", 0.0);  // Constructor Chaining
    }

    // Constructor 2 - Only name provided
    BankAccount(String name) {
        this(name, "0000", 0.0);
    }

    // Constructor 3 - Name and account number provided
    BankAccount(String name, String accNo) {
        this(name, accNo, 0.0);
    }

    // Constructor 4 - All details provided
    BankAccount(String name, String accNo, double balance) {
        this.name = name;
        this.accNo = accNo;
        this.balance = balance;
    }

    void display() {
        System.out.println("Name: " + name + ", Account No: " + accNo + ", Balance: ‚Çπ" + balance);
    }
}

 class BankAccountTest {
    public static void main(String[] args) {
        BankAccount a1 = new BankAccount();
        BankAccount a2 = new BankAccount("muna");
        BankAccount a3 = new BankAccount("kuna", "12345");
        BankAccount a4 = new BankAccount("Jiendra", "12346", 5000.0);

        a1.display();
        a2.display();
        a3.display();
        a4.display();
    }
}

In Java, variables are classified based on their scope, lifetime, and where they are declared.

types of variable in java
_______________________________

Types of Variables in Java:
1. Local Variable  
2. Instance Variable  
3. Static (Class) Variable  
4. Parameter Variable 
datatype variablename;

class classname
{
	datatype variablename;   
	static datatype variablename;
	classname()
	{
	   datatype variablename;
	}
	retyrntype methodname(datatype variablename)
	{
	    datatype variablename
	}
}

 1. Local Variable
Declared inside a method, constructor, or block.

Created when method is called, destroyed after method ends.

Not accessible outside the method.

class Demo {
    void display() {
        int localVar = 10;  // Local variable
        System.out.println("Local variable: " + localVar);
    }
    public static void main(String arg[])
    {
      Demo d=new Demo();
      d.display();
    }
}


2. Parameter Variable
Passed as an argument to a method or constructor.

Treated like a local variable.
class Demo {
    void sum(int a, int b) {  // a and b are parameter variables
        int result = a + b;
        System.out.println("Sum: " + result);
    }
      public static void main(String arg[])
    {
      Demo d=new Demo();
      d.sum(10,20);
    }
}




3. Instance Variable
Declared inside the class but outside any method or constructor.

Also called non-static variable.

Each object has its own copy.


class Demo {
    int instanceVar = 20;  // Instance variable

    void show() {
        System.out.println("Instance variable: " + instanceVar);
    }
}




Example:

 class X
 {
 	int a;  //instance variable

 }

 class Test
{
	
		public static void main(String arg[])
		{
			
		  X ob=new X();
		  System.out.println(ob.a);
		   

		}
}



o/p:
0


 class X
 {
 	int a;  //instance variable

 }

 class Test
{
	
		public static void main(String arg[])
		{
			
		  X ob=new X();
		  System.out.println(ob.a);
		  X obj=new X();
		  System.out.println(obj.a);
		  ob.a=10;
		  obj.a=20;
		   System.out.println(ob.a+" "+obj.a);
		   

		}
}



o/p:
0
0
10 20


 class X
 {
 	int a;  //instance variable

 }

 class Test
{
	
		public static void main(String arg[])
		{
			
		 
		  System.out.println(X.a);
		
		   

		}
}

o/p:
Test.java:14: error: non-static variable a cannot be referenced from a static context
                  System.out.println(X.a);
                                      ^
1 error


instance variable access static area must be required object.



class variable:
________________

3. Static (Class) Variable
Declared with the static keyword.

Shared among all objects.

Loaded only once at class loading time.

class Demo {
    static int staticVar = 30;  // Static variable

    static void display() {
        System.out.println("Static variable: " + staticVar);
    }
    public static void main(String arg[])
    {
        display();
    }
}






 class X
 {
 	static int a;  

 }

 class Test
{
	
		public static void main(String arg[])
		{
			
		 
		  System.out.println(X.a);
		
		   

		}
}

o/p:0




 class X
 {
 	static int a;  

 }

 class Test
{
	
		public static void main(String arg[])
		{
			
		 
		  System.out.println(X.a); //0
		  X ob=new X();
		  System.out.println(ob.a); //0
		  ob.a=10;
		  System.out.println(X.a); //10
		    System.out.println(ob.a); //10
		   

		}
}

o/p:
0
0
10
10



 class X
 {
 	static int a;  

 }

 class Test
{
	
		public static void main(String arg[])
		{
			
		
		  X ob=new X();
		  X ob1=new X();
		  ob.a=10;
		  ob1.a=30;
		  ob1.a=ob.a+ob1.a;
		  System.out.println(ob.a+"  "+ob1.a+"  "+X.a);
		   

		}
}



o/p:
60  60  60



 class X
 {
 	 int a;  

 }

 class Test
{
	
		public static void main(String arg[])
		{
			
		
		  X ob=new X();
		  X ob1=new X();
		  ob.a=10;
		  ob1.a=30;
		  ob1.a=ob.a+ob1.a;
		  System.out.println(ob.a+"  "+ob1.a);
		 // System.out.println(X.a); error
		   

		}
}


o/p:
10 40


differnce between class variable and instance variable
_____________________________________________________
 class X
 {
 	static  int a; 
 	 int b; 

 }

 class Test
{
	
		public static void main(String arg[])
		{
			
		  X ob=new X();
		  X ob1=new X();
		 ob.a=5;
		 ob.b=7;
		 ob1.a=10;
		 ob1.b=20;
		 System.out.println(ob.a+" "+ob.b); // 10  7
		 System.out.println(ob1.a+" "+ob1.b);//10 20
		   

		}
}



o/p:
10 7
10 20


 class X
 {
 	private static  int a; 
 	private  int b; 
 	X()
 	{
           ++a;
           ++b;
 	}
       void show()
       {
       	System.out.println(a+" "+b);
       }

 }

 class Test
{
	
		public static void main(String arg[])
		{
			
		  X ob=new X();
		  X ob1=new X();
		 X ob2=new X();
		 ob.show();
		 ob1.show();
		 ob2.show();

		}
}



o/p:
3 1
3 1
3 1


 class X
 {
 	private static  int a; 
 	private  int b; 
 	X()
 	{
           ++a;
           ++b;
 	}
       void show()
       {
       	System.out.println(a+" "+b);
       }

 }

 class Test
{
	
		public static void main(String arg[])
		{
			
		  X ob=new X();
		  ob.show();
		  X ob1=new X();
		   ob1.show();
		 X ob2=new X();
		 
		
		 ob2.show();

		}
}
o/p:
1  1
2 1
3 1




//count no of object
_______________________________
 class X
 {
 	static  int a; 
 	 
 	X()
 	{
           ++a;
         
 	}
       
 }

 class Test
{
	
		public static void main(String arg[])
		{
			
		  X ob=new X();
		
		  X ob1=new X();

		 X ob2=new X();
		 System.out.println(" no of object="+X.a);

		}
}






| Type      | Declared Inside           | Scope               | Lifetime           |
| --------- | ------------------------- | ------------------- | ------------------ |
| Local     | Method / Constructor      | Within method/block | During method call |
| Instance  | Inside class (non-static) | Per object          | Till object lives  |
| Static    | Inside class (static)     | Shared across class | Till class loaded  |
| Parameter | In method signature       | Within method only  | During method call |


class Demo {
    int instanceVar = 10;          // ‚úÖ Instance Variable (non-static, object-specific)
    static int staticVar = 20;     // ‚úÖ Static Variable (class-level, shared)

    Demo() {
        int constructorVar = 30;   // ‚úÖ Local Variable (constructor scope)
        System.out.println("Constructor Var: " + constructorVar);
    }

    void show(int paramVar) {      // ‚úÖ Parameter Variable (method parameter)
        int localVar = 40;         // ‚úÖ Local Variable (method scope)
        System.out.println("Instance: " + instanceVar);
        System.out.println("Static: " + staticVar);
        System.out.println("Parameter: " + paramVar);
        System.out.println("Local: " + localVar);
    }
}


class Test {
    public static void main(String[] args) {
        Demo d = new Demo();         // Constructor executes
        d.show(50);                  // Passing 50 as parameter variable
    }
}


Constructor Var: 30
Instance: 10
Static: 20
Parameter: 50
Local: 40

VariableType	     Name	               Where Declared	                           Scope
Instance Variable	instanceVar	     In class,     non-static	                 Per object
Static Variable	   staticVar	       In class, with static	                   Shared in class
Local Variable	  constructorVarlocalVar	Inside constructor / method	Only      in that block
Parameter Variable	paramVar	      In method parameter	                        Only inside method


why static method   // class method
_________________________
This method releated to class . common method for all object.  share method .
before object that method create.
non static and other static method call another static method directly.

(1)static data or (class data )  manipulation static method
(2)private static data static method needed
(3)private constructor    
(4)utility class   

(1)
class A
{
    static int data;
    static void show()
    {
        data=10;
        System.out.println(data); //10
    }
}
class Test
{
    public static void main(String arg[])
    {
          System.out.println(A.data);//0
           A.show();
           System.out.println(A.data);//10

    }
}


(2)private static data not acess outside class acess only static method
class A
{
   private static int data;
    static void show()
    {
        data=10;
        System.out.println(data); //10
    }
}
class Test
{
    public static void main(String arg[])
    {
         
           A.show();
         //System.out.println(A.data);//10 error

    }

}

(3)
private constructor we can not create object outside class.

class A
{
   private A()
   {

   }
}
class Test
{
    public static void main(String arg[])
    {
         
        //A ob=new A(); // error

    }

}

solution static method that class .

class A
{
   private A()
   {
        System.out.println("private constructor ");
   }
   static void create()
   {
       A ob=new A();
   }
}
class Test
{
    public static void main(String arg[])
    {
         //A ob=new A(); error
        A.create();

    }

}

o/p:
private constructor

singleton class
___________________
class create only one object .

rule:
private constructor
static method
static object refernce


class A {
    static A ob;             // Static variable to hold the single instance of class A

    private A() {
        // Private constructor to prevent instantiation from outside the class
    }

    static A create() {
        if (ob == null) {
            ob = new A();    // Object is created only once
        }
        return ob;           // Same object is returned every time
    }

    void show() {
        System.out.println("show method ");
    }
}

class Test
{
    public static void main(String arg[])
    {
       A obj=A.create();
       A obj1=A.create();
       System.out.println(obj == obj1);
      obj.show();
    }
}


(4) utilty class 

class contain only static variable and static method that class is known as utilty class.
That class object not reuried.

prdefined utilty class
_________________________
Math
Arrays

class Mymath
{
   static int c=0;
    static void add(int a,int b)
    {
       System.out.println("sum="+(a+b));
    }
    static int mult(int a,int b)
    {
        return a*b;
    }
}

class Test
{
    public static void main(String arg[])
    {
        Mymath.add(10,20);
        System.out.println(Mymath.mult(5,4));
         System.out.println(Mymath.c);
         Systemout.println(Math.pow(2,3));
    }
}



why nonstatic method   // instance  method //object method
____________________________________________________________________
A non-static method (also called instance method) belongs to the object of the class, not to the class itself.


Key Points
Feature               Non-Static Method
Belongs to  Object (Instance)
Access to Instance Variables    ‚úÖ Yes
Access to Static Variables  ‚úÖ Yes
Requires Object Creation    ‚úÖ Yes
Used When   Behavior varies per object

Reasons to Use Non-Static (Instance) Methods
To access or modify instance (non-static) variables

To perform object-specific behavior

To follow real-world object behavior modeling

To override in inheritance (polymorphism)

(1) Accessing Instance Variables
class Student {
    String name;  // instance variable

    void setName(String n)          //instance method
     {
        name = n;
    }

    void show()                            //instance method
    {
        System.out.println("Name: " + name);
    }
}

class Test {
    public static void main(String[] args) {
        Student s1 = new Student();
        s1.setName("Amit");
        s1.show();  // Output: Name: Amit
    }
}

Here, each object has its own name. So we need non-static methods to work with object-specific data.



(2) Object-Specific Behavior


class Circle {
    double radius;

    Circle(double r) {
        radius = r;
    }

    double area() {
        return 3.14 * radius * radius;
    }
}

class Test {
    public static void main(String[] args) {
        Circle c1 = new Circle(3);
        Circle c2 = new Circle(5);

        System.out.println(c1.area());  // Output: 28.26
        System.out.println(c2.area());  // Output: 78.5
    }
}
Each Circle object has a different radius, so the area() method must be non-static

(3) we can acess private instance outside class requried instance method
class A
{
    private int x;
    A()
    {
      x=10;
    }
    int getX()
    {
        return x;
    }

}
class Test
{
      publc static void main(String arg[])
      {
         A ob=new A();
         System.out.println(ob.getX());
      }
}

Static vs Non-Static Methods ‚Äì Quick Comparison
Feature             Static Method        Non-Static Method
Belongs to              Class                           Object
Objectrequired       ‚ùå No                      ‚úÖ Yes
Accesinstance var      ‚ùå No                    ‚úÖ Yes
Access static var        ‚úÖ Yes                ‚úÖ Yes
Common use case Utility, Singleton         Object-specific behavior


both static and non static method and variable  example
_____________________________________

class Employee {
    static String company = "ABC Ltd";  // shared by all
    String name;

    Employee(String name) {
        this.name = name;
    }

    void show() {
        System.out.println(name + " works at " + company);
    }

    static void changeCompany(String c) {
        company = c;
    }
}

class Test {
    public static void main(String[] args) {
        Employee e1 = new Employee("Ravi");
        Employee e2 = new Employee("Kiran");

        e1.show();  // Ravi works at ABC Ltd
        e2.show();  // Kiran works at ABC Ltd

        Employee.changeCompany("XYZ Ltd");

        e1.show();  // Ravi works at XYZ Ltd
        e2.show();  // Kiran works at XYZ Ltd
    }
}




static  block   and non static block
______________________________________

one class one time static block excute

 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");

        }

           static
         {
                 System.out.println("excution before static method only once ");
         }
}


o/p:

excution before static method only once
main method start


non static block
________________________
per object per non static block exceute.
 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");

        }

    
         {
                 System.out.println("excution non static block before constructor ");
         }
}


o/p:
main method start





 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");
           Test t=new Test();

        }


         {
                 System.out.println("excution non static block before constructor ");
         }
}



o/p:
main method start
excution non static block before constructor




 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");
           Test t=new Test();
           Test t1=new Test();
           Test t2=new Test();

        }


         {
                 System.out.println("excution non static block before constructor ");
         }
}


main method start
excution non static block before constructor
excution non static block before constructor
excution non static block before constructor



 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");
           Test t=new Test();
           Test t1=new Test();
           Test t2=new Test();

        }


         {
                 System.out.println("excution non static block before constructor ");
         }

         static
         {
             System.out.println("static block execute before static method only once");
         }
}



o/p:
static block execute before static method only once
main method start
excution non static block before constructor
excution non static block before constructor
excution non static block before constructor





 class Test
{
      
        Test()
        {
            System.out.println("Test constructor ");
        }
         public static void main(String arg[])
        {
            
           System.out.println("main method start");
           Test t=new Test();
           Test t1=new Test();
           Test t2=new Test();

        }


         {
                 System.out.println("excution non static block before constructor ");
         }

         static
         {
             System.out.println("static block excute before static method only once");
         }
}



o/p:
static block excute before static method only once
main method start
excution non static block before constructor
Test constructor
excution non static block before constructor
Test constructor
excution non static block before constructor
Test constructor




















class Test {
    
    // Static block: executes only once when class is loaded
    static {
        System.out.println("static block excute before static method only once");
    }

    // Non-static block: executes before constructor for each object
    {
        System.out.println("excution non static block before constructor ");
    }

    // Constructor: runs after the non-static block for each object
    Test() {
        System.out.println("Test constructor ");
    }

    public static void main(String[] args) {
        System.out.println("main method start");

        Test t = new Test();   // Object 1
        Test t1 = new Test();  // Object 2
        Test t2 = new Test();  // Object 3
    }
}

 Execution Flow
Class is loaded into memory ‚Üí static block executes once

main method starts

When an object is created:

Non-static block runs

Then constructor runs

This repeats for each object


o/p:
static block excute before static method only once
main method start
excution non static block before constructor 
Test constructor 
excution non static block before constructor 
Test constructor 
excution non static block before constructor 
Test constructor



class X
{
           X()
           {
                    System.out.println("X constructor ");
           }

         {
                 System.out.println(" non static block X ");
         }

         static
         {
             System.out.println("static block  X");
         }  
}

 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");
          

        }


}



o/p;
main method start





class X
{
           X()
           {
                    System.out.println("X constructor ");
           }

         {
                 System.out.println(" non static block X ");
         }

         static
         {
             System.out.println("static block  X");
         }  
}

 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");
          X ob=new X();

        }


}



o/p:
main method start
static block  X
 non static block X
X constructor



class X
{
           X()
           {
                    System.out.println("X constructor ");
           }

         {
                 System.out.println(" non static block X ");
         }

         static
         {
             System.out.println("static block  X");
         }  
}

 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");
          X ob=new X();
           X ob1=new X();

        }


}


o/p:
main method start
static block  X
 non static block X
X constructor
 non static block X
X constructor



only static block excute 
______________________________


class X
{
      static int a=10;
           X()
           {
                    System.out.println("X constructor ");
           }

         {
                 System.out.println(" non static block X ");
         }

         static
         {
             System.out.println("static block  X");
         }  

}

 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");
           System.out.println(X.a);

        }


}


o/p:

main method start
static block  X
10


class X
{
      static int a=10;
           X()
           {
                    System.out.println("X constructor ");
           }

         {
                 System.out.println(" non static block X ");
         }

         static
         {
             System.out.println("static block  X");
         }  

}

 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");
           System.out.println(X.a);
           System.out.println(X.a);

        }


}



o/p:
main method start
static block  X
10
10




class X
{
       static void show()
       {
         System.out.println("show static method ");
       }
           X()
           {
                    System.out.println("X constructor ");
           }

         {
                 System.out.println(" non static block X ");
         }

         static
         {
             System.out.println("static block  X");
         }  

}

 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");
           X.show();

        }


}
o/p:
main method start
static block  X
show static method










class X
{
       static void show()
       {
         System.out.println("show static method ");
       }
           X()
           {
                    System.out.println("X constructor ");
           }

         {
                 System.out.println(" non static block X ");
         }

         static
         {
             System.out.println("static block  X");
         }  

}

 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");
           X.show();

        }


}


o/p:
main method start
static block  X
show static method
show static method




class X
{
       void show()
       {
         System.out.println("non static show method ");
       }
           X()
           {
                    System.out.println("X constructor ");
           }

         {
                 System.out.println(" non static block X ");
         }

         static
         {
             System.out.println("static block  X");
         }  

}

 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");
          X ob=new X();
          ob.show();
        }


}


o/p:

main method start
static block  X
 non static block X
X constructor
non static show method



class X
{
       void show()
       {
         System.out.println("non static show method ");
       }
           X()
           {
                    System.out.println("X constructor ");
           }

         {
                 System.out.println(" non static block X ");
         }

         static
         {
             System.out.println("static block  X");
         }  

}

 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");
          X ob=new X();
          ob.show();
          ob.show();
        }


}

o/p:

main method start
static block  X
 non static block X
X constructor
non static show method
non static show method


class X
{
       void show()
       {
         System.out.println("non static show method ");
       }
           X()
           {
                    System.out.println("X constructor ");
           }

         {
                 System.out.println(" non static block X ");
         }

         static
         {
             System.out.println("static block  X");
         }  
         static void disp()
         {
            System.out.println("static disp method ");
         }

}

 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");
           X.disp();
        }


}

C:\Users\LENOVO\OneDrive\Desktop\JAVAPROGRAMOOPS>java Test
main method start
static block  X
static disp method




class X
{

       static int x;  //class variable // static data memeber
       int y; //non static dattamember //instance variable
       
           X()
           {
                    System.out.println("X constructor " +"  "+x+"  "+y);
           }

         {
                 System.out.println(" non static block Y= "+y);
         }

         static
         {
             System.out.println("static block  X value= "+x);
         }  
         static int show()
         {
            x=5;
            return x+2;

         }
             int disp()
         {
            y=10;
            return y+2;

         }

}

 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");
           X ob=new X();
        }


}

o/p:
main method start
static block  X value= 0
 non static block Y= 0
X constructor   0  0




class X
{

       static int x=show();  //class variable // static data memeber
       int y=disp(); //non static dattamember //instance variable
       
           X()
           {
                    System.out.println("X constructor " +"  "+x+"  "+y);
           }

         {
                 System.out.println(" non static block Y= "+y);
         }

         static
         {
             System.out.println("static block  X value= "+x);
         }  
         static int show()
         {
            System.out.println("x initlize ");
            x=5;
            return x+2;

         }
             int disp()
         {
            System.out.println("y initlize ");
            y=10;
            return y+2;

         }

}

 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");
           X ob=new X();
        }


}


o/p:
main method start
x initlize
static block  X value= 7
y initlize
 non static block Y= 12
X constructor   7  12




class X
{

       static int x=show();  //class variable // static data memeber
       int y=disp(); //non static dattamember //instance variable
       
           X()
           {
                    System.out.println("X constructor " +"  "+x+"  "+y);
           }

         {
                 System.out.println(" non static block Y= "+y);
                 y=40;
         }

         static
         {
             System.out.println("static block  X value= "+x);
             x=30;
         }  
         static int show()
         {
            System.out.println("x initlize ");
            x=5;
            return x+2;

         }
             int disp()
         {
            System.out.println("y initlize ");
            y=10;
            return y+2;

         }

}

 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");
           X ob=new X();
           System.out.println(ob.x+" "+ob.y);
        }


}

o/p:

main method start
x initlize
static block  X value= 7
y initlize
 non static block Y= 12
X constructor   30  40
30 40




class X
{

      
       
           X()
           {
                    System.out.println("X constructor " +"  "+x+"  "+y);
           }

         {
                 System.out.println(" non static block Y= "+y);
                 y=40;
         }

         static
         {
             System.out.println("static block  X value= "+x);
             x=30;
         }  
         static int show()
         {
            System.out.println("x initlize ");
            x=5;
            return x+2;

         }
             int disp()
         {
            System.out.println("y initlize ");
            y=10;
            return y+2;

         }
          static int x=show();  //class variable // static data memeber
       int y=disp(); //non static dattamember //instance variable

}

 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");
           X ob=new X();
           System.out.println(ob.x+" "+ob.y);
        }


}


C:\Users\LENOVO\OneDrive\Desktop\JAVAPROGRAMOOPS>javac Test.java
Test.java:12: error: illegal forward reference
                 System.out.println(" non static block Y= "+y);
                                                            ^
Test.java:18: error: illegal forward reference
                 System.out.println("static block  X value= "+x);
                                                              ^
2 errors





class X
{

       static int x=show();  //class variable // static data memeber
       int y=disp(); //non static dattamember //instance variable
       
           X()
           {
                    System.out.println("X constructor " +"  "+x+"  "+y);
           }

         {
                 System.out.println(" non static block Y= "+y);
                 y=40;
         }

         static
         {
             System.out.println("static block  X value= "+x);
             x=30;
         }  
         static int show()
         {
            System.out.println("static  initlize ");
            x=5;
            return x+2;

         }
             int disp()
         {
            System.out.println("non static  initlize ");
            y=10;
            return y+2;

         }
         static int z=show();
         int zz=disp();

}

 class Test
{
      
        
         public static void main(String arg[])
        {
            
           System.out.println("main method start");
           X ob=new X();
           System.out.println(ob.x+" "+ob.y+" "+ob.z+" "+ob.zz);
        }


}



o/p:
main method start
static  initlize
static block  X value= 7
static  initlize
non static  initlize
 non static block Y= 12
non static  initlize
X constructor   5  10
5 10 7 12



 Java Execution Order ‚Äì Summary Table
Execution Step  What Runs   When
1Ô∏è Static variables (in declaration order) When class is loaded (first time only)
2Ô∏è Static blocks   After static variables
3Ô∏èInstance variables (in declaration order)   Every time object is created
4Ô∏è Non-static blocks   After instance variables, before constructor
5Ô∏è Constructor After non-static block 



https://chatgpt.com/share/687dd2aa-804c-8008-be91-4da2700fe4a7